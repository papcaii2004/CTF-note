# Exploiting after `exit()`

## Description
When `main()` returns, libc executes `__run_exit_handlers()`.  
This function manages exit callbacks (`atexit()`) stored in `__exit_funcs`.  
If we can overwrite entries in this list, we can redirect execution **after `main` returns**.

## Example – Imaginary CTF 2025: twowrite
- Primitive: Arbitrary write (two writes).
- Technique: Overwrite pointer in `__exit_funcs`.
- Result: Hijack execution after normal program termination.

```c
/* simplified glibc logic */
void __run_exit_handlers (...) {
    while (exit_function_list != NULL) {
        (*exit_function_list->func)();
    }
}
```

### Steps
1. Leak libc base.
2. Locate `__exit_funcs` (via symbol or offset).
3. Overwrite a function pointer inside with `system("/bin/sh")` or ROP chain.
4. Let `main()` return naturally → shell.

## References
- glibc source: stdlib/exit.c
- Related: `_dl_fini`, `__libc_start_main` cleanup phase
- [From exit to system](https://blog.rop.la/en/exploiting/2024/06/11/code-exec-part1-from-exit-to-system.html)